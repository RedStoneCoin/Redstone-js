describe('homomorphic', () => {
    it.skip('can sign (homomorphic)', () => {
        const db = Secp256k1.uint256('D30519BCAE8D180DBFCC94FE0B8383DC310185B0BE97B4365083EBCECCD75759', 16)
        const sig = Secp256k1.ecsign2(db, d, z)
        Assert.ok(/^[0-9a-f]{64}$/.test(sig.r), 'sig.r is not a hex string')
        Assert.ok(/^[0-9a-f]{64}$/.test(sig.s), 'sig.s is not a hex string')
        Assert.ok(sig.v===0 || sig.v===1, 'sig.v is not a 0 or 1')
        const pub = Secp256k1.ecrecover(sig.v, Secp256k1.uint256(sig.r,16), Secp256k1.uint256(sig.s,16), z)
        Assert.deepStrictEqual(pub, {
            x: 'b7f186b476f99f5ffc18e236128c8be8884c1f889ed4d77818e3e53d3d714643',
            y: '2f8c937534b5188ba04decfb2d9358aa7ebbb702ccc76091379ac59c46022311' })
        if (Secp256k1Node) {
            const Q = Secp256k1Node.recover(B(z), Buffer.concat([B(sig.r), B(sig.s)]), sig.v, false)
            Assert.deepStrictEqual({x: Q.toString('hex').substr(2,64), y: Q.toString('hex').slice(-64)}, pub)
        }
    })
})

