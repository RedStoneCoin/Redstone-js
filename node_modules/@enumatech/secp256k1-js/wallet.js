function fromHex(hex) {
    return hex.match(/\w{2}/g).map(a => parseInt(a, 16))
}

function toBase64url(bytes) {
    return btoa(bytes).replace(/=*$/, '').replace(/\//g, '_').replace(/\+/g, '-');
}

function toArrayBuffer(text) {
    return new TextEncoder('utf-8').encode(text)
}

function fromArrayBuffer(ab) {
    return String.fromCharCode.apply(null, new Uint8Array(ab))
}

function generatePublicKeyFromPrivateKeyData(privateKey) {
    const d = uint256(new Uint8Array(privateKey));
    return mulG(d);
}

function getAddressK1(publicKey) {
    return keccak_256(fromHex(publicKey)).slice(-40)
}

function deriveKeyFromWordList(wordlist, passphrase) {
    return window.crypto.subtle.importKey('raw', toArrayBuffer(wordlist), {
        name: "PBKDF2"
    }, false, ["deriveBits"]).then(key => {
        const salt = toArrayBuffer(passphrase)
        return window.crypto.subtle.deriveBits({
            name: "PBKDF2",
            salt: salt,
            iterations: 10000,
            hash: "SHA-256"
        }, key, 256)
    }).then(key => {
        return new Uint8Array(key)
    })
}

function padLeft0(str, pad) {
    return ("00000000000000000000000000000000" + str).slice(-pad)
}

function sha256(buffer, encoding) {
    return crypto.subtle.digest("SHA-256", buffer).then(function (hashBuffer) {
        if (encoding === 16 || encoding === 'hex') {
            const hashArray = Array.from(new Uint32Array(hashBuffer));
            return hashArray.map(b => padLeft0(b.toString(16), 8)).join('');
        }
        else {
            return new Uint8Array(hashBuffer)
        }
    })
}

function signWithKeyData(keyData, digestData) {
    return sha256(digestData).then(digest => {
        const d = uint256(keyData)
        const z = uint256(digest)
        const sig = ecsign(d, z)
        const v = '00' // TODO: determine v 00 or 01
        return padLeft0(sig.r.toString(16), 64) + padLeft0(sig.s.toString(16), 64) + v
    })
}

function createHmacJws(typ, message, secret, cty) {
    const jose = {typ: typ, alg: 'HS256', cty: cty}
    if (typeof message !== 'string') {
        message = JSON.stringify(message)
    }
    const jwt = toBase64url(JSON.stringify(jose)) + '.' + toBase64url(message)
    return window.crypto.subtle.importKey('raw', toArrayBuffer(secret), {name: "HMAC", hash: {name: 'SHA-256'}}, false, ["sign"]).then(key => {
        return window.crypto.subtle.sign("HMAC", key, toArrayBuffer(jwt))
    }).then(sig => {
        return jwt + '.' + toBase64url(fromArrayBuffer(sig))
    })
}

function httpGet(url) {
    const appId = 'test.js'
    const secret = '76doowNfy9iojytl5X0hrEN3g0zXweqWYEZNwiAANGA='
    return createHmacJws('JWT', {iss: appId, aud: url}, secret).then(jwt => {
        return fetch(url, {headers: {authorization: 'bearer ' + jwt}}).then(result => {
            return result.json()
        }).then(json => {
            if (json.error) {
                throw Error(json.error.message)
            }
            return json.data
        })
    })
}

function revokeByRecoveryKey(recoveryKey) {
    const backendUrl = 'https://issuer.trustedkey.com/'

    const publicKey = generatePublicKeyFromPrivateKeyData(recoveryKey)
    const addressHex = getAddressK1(publicKey.toString(16))
    const address = new Uint8Array(fromHex(addressHex))
    const rawAddressHex = "0x" + addressHex
    console.log(rawAddressHex)

    const suffix = toArrayBuffer('revocation')
    const mandate = new Uint8Array(address.byteLength + suffix.byteLength);
    mandate.set(address, 0);
    mandate.set(new Uint8Array(suffix), address.byteLength);

    return signWithKeyData(recoveryKey, mandate).then(sigHex => {
        const url = `${backendUrl}revokeByRecoveryKey?signature=${sigHex}&address=${rawAddressHex}`
        return httpGet(url).then(data => {
            if (data.revokeByRecoveryKey !== true) {
                throw Error('Revocation by recovery key failed')
            }
            return true
        })
    })
}
